BUGS:
* GCC 4.0.1
* bug may25 rob chapman (interface).
* bug jun14 peter TB brett (unconstr out assigned with (others => x))
* bug stephen leak
* bug elab of pr/warnings-0/conf1.vhdl (unconstrained signals)
* bug ~/conf2.vhdl: arch subprogram is not translated for config (check with
  ghdl1-debug).
* bug ~/conf3.vhdl: problem while counting signals.
* from a typical vhdl file, create new files with 1 or more tokens removed.
  Check diags.
* bug IR2069
* bug unconstrained port and func conv: see IR2064
* bug david-kuehling with signals (array_subtype_ptr)
* translate_object: no parent.
* waves: verilog types, physical types.
* waves: ghwdump util to be put into ghdl exec ?
* grt: --dump-rti, --dump-signals: modules?
todo: web site: add ghdl.ps, ghdl.pdf

PEFS:
* DONE: add an hash table for primary unit (cf unisim).
* use hash table for get_lastest_arch
* DONE: ieee_xxx_resolv for ghdl_run

* TOP:
* vhdl93
* DONE: new node format
* DONE: grt: do not depends on libgnat [malloc/free; gnat.table; rcheck; stdio]
* sem_name: check all possibilities, recursion on prefix for finish_ and free.

* length : use left and right from type range if any.
* subtype descriptor : can be a const.
* checks on type (values out of bounds).
* deallocate: in depth.
* iterator on array elements.

* GHDL:
* DONE: val_staticness for aggregates
* libraries: the first line of the .cf files must contains options/standard.
* global file for setup (vhdl version, mapping)
* eval static expressions automaticaly.
* check for no return in a function, generate code to catch this error.
* DONE: detect no wait in processes.
* clean-up dependences check (cf libraries.is_obsolete)
* AMS-VHDL: reserved keywords
* replace implicit_functions of type decl with implicit_subprograms
* add an option to disable eval_if_static_expr (to check more).
* handle "-- pragma xxx"
* handle locally static disconnection_spec in canon
* use MD5/SHA1 instead of dates
* add_dependence: add a flag to mark dependence (to be restored/backuped)
* visible_flag: check for operator
* individual assocs: multi-dim arrays
* static name: if the value is an access, the name is not static.
* DONE: preference for universal primitives (function call).
* check rules for building default sensitivity list.
* overload in case/select signal assignment
* array access subtype.
* DONE: triple use clauses
* DONE: use clauses (list)
* visibility in configuration declaration.
* DONE: hide implicit defined subprograms when overridden by explicit one.
* DONE: script to do all checks from a tar file
* DONE: sem_name -> sem_scopes
* DONE: sem_names.ads/adb
* DONE: eval string literal (add list)
* DONE: export files for GCC, build in GCC.
* DONE: name visibility
* DONE: create iir_kind_error 
* DONE: add base_name field for _name iirs.
* DONE: check accesses with base_name.
* attributes: check all entity name kind (labels, file...)
* DONE: attributes: only one per simple name.
* incremental binding: different entity in entity aspect of primary binding.
* DONE: overload number in IIRS.
* subprogram_instances: remove decl_type (only use ptr_type).
* pure during elab: load package only if necessary.
* purity state of implicit subprograms.
* seen_flag: remove (unused).
* DONE: location_end: add for design units.
* 'image, 'value: eval_static_expr, to be completed.

* IIRS:
* formats: Declaration, Integer, Real, Small, Medium
* + lists
* common: kind/flags/staticness/digits (32), loc(32)
          4 fields (4 * 32) + back_end (??) + parent (??)
* Integer: + int (64) (?? for physicals: origin,unit,type)
* real:    + real (64)
* small:   + 2 fields (2 * 32)
* medium:  + 2 + 7 fields (9 * 32)
* Decls:   + link (32), ident (32), attr (32), parent (32),
	     1+2+4 fields (7 * 32) + second link (?)

* ghdlmake:
* DONE: add object files from grt
* selection of run time?
* DONE: object files location (fix how std is currently handled).
* verbose or long flag for -d: disp file name
* handle multiple libraries
* -n: do not compile/elaborate.
* DONE: -cargs: additional args for compiler (+ -largs)
* add dependences for all design units.
* create or accept WAVES header for compilation order
* -i: incremental analyse: analyse only if not up to date
* -m: re-read library file before final elaboration, because dependences may
  have changed.
* -m : to be renamed to -u
* use default configurations for dependences
* DONE: add other files
* add these options: --AS=, --LD=, --POST=, -static, -shared
* -m bugs: hc11core, fphdl
* create configuration
* DONE: chop

* VITAL:
* CELLTYPE
* finish Level0
* SDF 3.0, 4.0
* SDF: bus, all types
* negative delay

* elaboration:
* DONE: late binding
* DONE: should load the top entity to check for no generics nor in ports.
* DONE: should load package body to check passive subprg/no wait in subprg.
* elab port based on assoc list
* bug if instantiated entity is the same as the current instance ?

* grt:
* DONE: vcd: dump only when value has changed.
* vcd: handle record
* create vcd/tdml header
* set fpu in exception mode
* DONE: resize process stacks/trap stack underflow
* create a global event list, to increase speed (each signal is an element of
  the list)
* DONE: add name of processes (as an instance)

* Optimizations:
* DONE: reduce number of signals (components, instantiation...)
* DONE: std_logic signals with only one driver.
* range checks.

* translate:
* record/array file types
* DONE: aggregate target for variables
* DONE: create description of instance with an array instead of names
* DONE: create names for prefix instead of uniq id
* DONE: no type_desc for types that can't be used for signals (ex: types
  defined in subprg or processes).
* do not create signals types for constant/variable, but always create value
  types.
* rewrite procedure/function interfaces.
* attribute names
* do not translate all predefined subprograms: flag_use to be added
  be careful to packages and entity.
* WRONG: do not add instance for pure functions -> maybe required for types.
* free info
* DONE: finalization (files)
* DONE: extended identifiers
* check for no return in a function (and catch at execution time)
* range check: be smarter
* range for for-loop, slices, generates.
* flag_review: add more comments.
* DONE: alias : handle more than arrays.
* add a length field in array bounds for multi-dim array
* DONE: create an elaborator for components
* NOT RELEVANT: check for unused types infrastructures (_STB for array index)
* create signal builder for record/array (see composite_types.vhdl)
* DONE: handle package body while not necessary
* individual assoc in subprograms
* individual assoc for predefined proc (file procedures)
* check for file with same basename (ex: a.vhd and a.tvhd), since the object
  file will overwrite (or add a number ex: 00_a.o 01_a.o)

* ortho_gcc:
* overflow
* conversion

* ortho:
* DONE: check for use of variable out of its scope (add a in_use flag ?).
* -> check for no enode after a statement.
* standard types metrics.
* DONE: check scope for variables/constant/subprograms.
* enum -> new_lit
* for debug: disp/read enum size.
* new_ref -> from variable/interface/const to l_node
* offset type
* debug: check ident (redefine, overridden)

* tests
* all interfaces.
* arrays: constant, variable, signal, alias, default value,
          slice, assign, index, 'range,left,right,length attributes
* alias

* VHDL quizz:
* A and B and C, where and is not predefined and not associative -> order
  defined by lrm
* event without value change -> not possible to create such a design
* for I in 0 to 4 + 5 loop 
* my_int; function "not" (v : my_int := 0) return my_int; var := "not";
* read operation for array with multiple indexes -> not allowed
* A <= (others => 0) where A is a subprogram formal interface whose type is
  an unconstrained array.
*B function returning a file type.
* null string when index base type left bound has no pred.
* arch x of y is
    attribute my_attr of my_inst : label is 25;
    component my_comp ... end component;
  begin
    my_inst : my_comp;
  end x;
  Is my_comp a component or a procedure call ? -> label
* element declaration scope does not extend beyond a package scope -> the
  package scope is extended along with the scope of the logical library.
* labeled statement inside a for-loop can be attributed.
* "wait on S'transaction' not allowed since an attribute is not a static name.
*B constant c : integer := 3 ** 4; which "**" (universal or integer)?
   or: constant c : integer := - 1; (which "-" ?)
*B type chrptr is access character;
  type chrptr_array is array (natural range <>) of chrptr;
  -> creates an implicit function "&" whose interface is constant of type
     access. 
* package ch1003_002_pkg is
     type my_bit is ('0', '1', 'X');
     function "=" (l, r : my_bit) return boolean;
  end ch1003_002_pkg;
  ...
  use work.ch1003_002_pkg.all;
  ...
       A = B --  A and B of type my_bit
  Both the implicit and explicit "=" operator are visible!
* package p is
    function f return integer;
  end p;
  
  use work.p.all;
  package p is
    constant c : integer := f;
  end p;
* redeclaration of a design unit in vhdl02 (not allowed ?)
* 'FOREIGN for implicit subprograms ?
* 'FOREIGN with non-locally static value
*B alias of a physical type (not possible, since only the subtype is named).
* 'a''attr -> not allowed.
*B2 visibility in context clause:
  library my_lib;
  entity ent is end ent;

  use my_lib.my_pkg.all;
  architecture arch of ent is ...
* 4.2 Subtype declarations: "if a type mark is the name of a type, the type
  mark denotes this type and also the corresponding unconstrained subtype."
  What is the corresponding subtype of an enumeration type ?
  -> 3.0  "A type is a subtype of itself"
* name'a'length has no characters...
*B2 with expr select (a,b) <= "01" when c1, val when others;
  -> type of aggregate is not determinable!!
  -> or type of aggregate depends on the selected expression
   (ex: (a,b) std_logic_vector and then std_ulogic_vector)
* case statement: expression which is an indexed name and of unidim array type
  (why are the indexes locally static expressions ?)
* Is an alias overloadable (?) -> yes
* 5.2 Configuration specification: 'others' -> meaning of 'previous'
  incremental binding for different entity aspect.
  component_configuration that is a primary binding for some instantiation
    and an incremental binding indic for others.
*B 14.1 'instance_name example: missing ';' after generic clause of BComp
  component; missing ":" before gbottom'path_instance;
  signature is added for subprograms but not for enumeration literals.
  loop_label ?
  staticness
  root design entity (E'PATH_NAME) vs top design entity (E'INSTANCE_NAME)
  meaning of signature ?
* 10.3 (last paragraph of p 155): 'of a design unit_or' (place of '_').
*B 3.5.1 vs 3.5.2: in examples: VariableSizedBitArray vs VariableSizeBitArray.
* 4.2.2: is a default_expression globally static ?
* 5.1: alias of attribute are allowed ->
  constant obj : bit := '0';
  attribute attr : integer;
  alias attr1 is attr;
  attribute attr of obj : constant is 5;
  ...  obj'attr1 ...
* 5.1: entity designator that denotes an alias .. required to denote the
  entire object.  What means entire ? staticness of entire ?
  constant obj : bit_vector (1 to 3);
  alias obj1 : bit_vector (2 to 4) is obj (1 to 3);
* 8.1:
  process
  begin
     wait for time'high - now;
  end process;
  -> infinite loop or execute only once ?
  (ie does it execute at time'high ?)
*B Does a generate statement have a declarative_part ?
  according to the BNF of 9.7 and glossary -> no
  according to introduction of clause 9 -> yes
  -> does configuration specification applies recursively ?
* Can a design unit be decorated with an attribute specification whose entity
  name list is all/others ? (cf notes of 5.1)
* Can an alias be declared after an all/others attribute specification ?
* Can a named entity be decorated through an alias not declared in the same
  declarative part ?
* Can an anonymous type declaration be decorated ?
*B character literal can be decorated but not referenced.
*B wait on sig (now < 10 ns);
*B pure function can allocate memory and may return different value
*B2 what it the meaning of a name when several non-overloadable declarations
  are visible (one directly, one by selection).
* 'value: only *one* leading/trailing whitespace allowed ?

* libraries:
* V:version, O:option, S:set/standard
* F:file, D:depend, T:time, U:unit, L:location/line
* A:architecture, E:entity, P:package, B:body, C:configuration
* M:module/map (library name to filename), W:with (weak depend), X:translate
* I:instanciated component
* H:homedir
* G J K N Q R Y Z
* + search path, vhdl version, ieee libraries.

* aggregates:
- dynamic bounds -> special case
- bounds are determinated by target
- static bounds and determinated by the aggregate
- static bounds and static values.

BUGS:
* no type descriptor is created for access.  However, a type descriptor is
  created for array and use the type descriptor of its element.  What about
  for array whose element is an access ?

OPTIMIZATIONS:
* for loop whose range is an array index.
* avoid to initialize variable if not read before write.
* avoid stupid range check (ex: a := b, when subtype b = subtype a).

ERROR STORMS:
* complex_tests: real_vector -> real_vectorX
